
# 2022

**3.05** 

206 反转链表

注意要从输入链表的第一个开始反转，如果从最后一个开始反转的话会造成链表出现循环。

自己想的方法是借助队列，空间复杂度高，需要遍历两遍

好方法是一遍结束，用temp变量来记录原链表的下一位，然后用curr和prev两个变量来进行反转

递归方法：


**3.06**

53 最大子序和

自己没想出来

好方法是DP，创建dp列表，从头开始记录当前能取得的最大值，而后返回dp表的最大值。


**3.10**
121 买股票 dp

**3.11**

21合并链表，循环法即反复横跳，递归法即每次输入最小

141环形链表，快慢指针

160相交链表，可能不等长但末尾部分是相等的，利用长度差。

**3.12**

206 反转链表 C++

138 复制带随机指针的链表 C++ 
    链表循环，计算长度
    hashmap `unordered_map<int, str> umap;` 类似于python字典

**3.13**

20 有效括号 Stack

1 两数相加 Hashmap


**3.14**
88 合并两个有序数组 没有想到更高级的方法，只用C++实现了冒泡排序

71 简化路径 

**3.15**

1249  栈 没有做到最简，用的比较笨的两次遍历

26 双指针

**3.16**

946 验证栈序列，py 判断逻辑复杂，要理清之后进一步精简。

**3.19**

125 有效回文序列

**3.20**

88 合并两个有序数组 冒泡排序py

**3.21**

88 合并两个有序数组 双指针，从后向前

141 环形链表 快慢指针C++

**3.22**

19 删除链表倒数第n个节点 双指针计数

237 删除节点，问题不严谨。


**3.23**

415 处理字符串

**3.24**

670 最大交换 

**3.25**
876 链表中点 双指针异常简单

**3.26**

409 最长回文 哈希表或者set