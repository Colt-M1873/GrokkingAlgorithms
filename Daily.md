
# 2022

**3.05** 

206 反转链表

注意要从输入链表的第一个开始反转，如果从最后一个开始反转的话会造成链表出现循环。

自己想的方法是借助队列，空间复杂度高，需要遍历两遍

好方法是一遍结束，用temp变量来记录原链表的下一位，然后用curr和prev两个变量来进行反转

递归方法：


**3.06**

53 最大子序和

自己没想出来

好方法是DP，创建dp列表，从头开始记录当前能取得的最大值，而后返回dp表的最大值。


**3.10**
121 买股票 dp

**3.11**

21合并链表，循环法即反复横跳，递归法即每次输入最小

141环形链表，快慢指针

160相交链表，可能不等长但末尾部分是相等的，利用长度差。

**3.12**

206 反转链表 C++

138 复制带随机指针的链表 C++ 
    链表循环，计算长度
    hashmap `unordered_map<int, str> umap;` 类似于python字典

**3.13**

20 有效括号 Stack

1 两数相加 Hashmap


**3.14**
88 合并两个有序数组 没有想到更高级的方法，只用C++实现了冒泡排序

71 简化路径 

**3.15**

1249  栈 没有做到最简，用的比较笨的两次遍历

26 双指针

**3.16**

946 验证栈序列，py 判断逻辑复杂，要理清之后进一步精简。

**3.19**

125 有效回文序列

**3.20**

88 合并两个有序数组 冒泡排序py

**3.21**

88 合并两个有序数组 双指针，从后向前

141 环形链表 快慢指针C++

142 环形链表2 快慢指针C++ 加上一些数学推导

**3.22**

19 删除链表倒数第n个节点 双指针计数

237 删除节点，问题不严谨。


**3.23**

415 处理字符串

**3.24**

670 最大交换 

**3.25**
876 链表中点 双指针异常简单

**3.26**

409 最长回文 哈希表或者set

**3.27**
21 合并两个有序数组 CPP iterative recursive


**3.28**

234 回文链表 双指针 栈

23 合并K链表 recursive 参照21题

思路不清晰的话先想暴力法，直接想高级做法容易卡关，先把暴力做出来再考虑优化时间，有时候写着暴力就想到了更高级的解法。


**3.29**

61 旋转链表 18min

287 寻找重复数 用数组当哈希表，哈希表，sort()，set()，数组看作链表类似142，改进二分搜索，位操作， 共7到8种方法
    287是很有意思的一道题，明明是数组但是能用和环形链表一样的方式去考虑


**3.30**

74 搜索2d矩阵 二分法搜索


**4.02**

3


**4.04**

1721


**4.05**

11

**4.09**

347



**4.14**

700 二叉搜索树，二叉查找树 1用队列进行层序遍历，2递归，3用二叉搜索树的有序特性来比较大小

144 前序遍历 1递归，2用栈循环

145 后序遍历 1递归，2用栈循环反向输出

94 中序遍历 1递归，2循环


https://leetcode.com/problems/binary-tree-inorder-traversal/discuss/713539/Python-3-All-Iterative-Traversals-InOrder-PreOrder-PostOrder-Similar-Solutions

↑统一的前中后序遍历

