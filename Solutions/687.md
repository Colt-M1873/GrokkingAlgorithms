ã€CyberDJã€‘[Go | Python] DFS 8è¡Œé€’å½’ / å¾ªç¯ååºéå† [ Ê•â—”Ï–â—”Ê”  | ğŸ]

## 1 é€’å½’ï¼ˆä½¿ç”¨éå±€éƒ¨å˜é‡ï¼‰

ä¸å®˜æ–¹é¢˜è§£ä¸­ç›¸åŒ

```Python 
def longestUnivaluePath(self, root: Optional[TreeNode]) -> int:
    currMax=0
    def recursiveDFS(root):
        if not root : return 0
    leftMax=recursiveDFS(root.left)
    righMax=recursiveDFS(root.right)
    if root.left and root.val==root.left.val:
        leftMax+=1
    else:
        leftMax=0
        if root.right and root.val==root.right.val:
            righMax+=1
        else:
            righMax=0
            nonlocal currMax
            currMax=max(currMax,leftMax+righMax)
            return max(leftMax,righMax)
        recursiveDFS(root)
        return currMax
```
```Golang 
func longestUnivaluePath(root *TreeNode) int {
    currMax:=0
    var recDFS func(node *TreeNode) int
    recDFS = func(node *TreeNode) int {
        if node==nil {return 0}
        leftPath:=recDFS(node.Left)
        rightPath:=recDFS(node.Right)
        if node.Left!=nil && node.Val==node.Left.Val{
            leftPath++
        }else{
            leftPath=0
        }        
        if node.Right!=nil && node.Val==node.Right.Val{
            rightPath++
        }else{
            rightPath=0
        }
        if leftPath+rightPath>currMax{
            currMax=leftPath+rightPath
        }
        if leftPath>rightPath{
            return leftPath
        }
        return rightPath
    }
    recDFS(root)
    return currMax
}
```

## 2 é€’å½’ï¼ˆ8è¡Œï¼Œä¼ å‚ä»£æ›¿éå±€éƒ¨å˜é‡ï¼‰

ä¸ä½¿ç”¨éå±€éƒ¨å˜é‡çš„æ–¹æ¡ˆï¼Œé€šè¿‡ä¼ å‚æ¥ä»£æ›¿éå±€éƒ¨å˜é‡ï¼ŒmaxLå’ŒmaxRåˆ†åˆ«æ˜¯å·¦å³èŠ‚ç‚¹å¯¹åº”çš„æœ€é•¿å¯èƒ½è·¯å¾„ï¼ˆå³ä¸Šä¸€ç§æ–¹æ¡ˆé‡Œçš„currMaxï¼‰

```Python
def longestUnivaluePath(self, root: Optional[TreeNode]) -> int:
    def recDFS2(root):
        if not root: return 0, 0
    maxL, pathL  = recDFS2(root.left)
    maxR, pathR = recDFS2(root.right)        
    pathL = pathL + 1 if root.left and root.left.val == root.val else 0
    pathR = pathR+ 1 if root.right and root.right.val == root.val else 0
    return max(maxL, maxR, pathL + pathR), max(pathL, pathR)
return recDFS2(root)[0]
```

```Golang
func longestUnivaluePath(root *TreeNode) int {
    var recDFS func(node *TreeNode) (int,int)
    recDFS = func(node *TreeNode) (int,int) {
        if node==nil {return 0,0}
        maxL,pathL:=recDFS(node.Left)
        maxR,pathR:=recDFS(node.Right)
        currMax:=max(maxL,maxR)
        if node.Left!=nil && node.Val==node.Left.Val{
            pathL++
        }else{
            pathL=0
        }        
        if node.Right!=nil && node.Val==node.Right.Val{
            pathR++
        }else{
            pathR=0
        }
        currMax=max(currMax,pathL+pathR)
        return currMax, max(pathL,pathR)
    }
    ret,_:=recDFS(root)
    return ret
}
func max(a,b int) int{
    if a>b {return a}
    return b
}
```

## 3 å¾ªç¯ååºéå†

ååºéå†ï¼Œä¸åŒäºé€’å½’å½¢å¼é‡Œç›´æ¥é€šè¿‡é€’å½’å‡½æ•°æ¥è¿”å›è·¯å¾„é•¿åº¦ï¼Œååºéå†ä¸­ç”¨å­—å…¸dæ¥å­˜å‚¨èŠ‚ç‚¹å¯¹åº”çš„è·¯å¾„é•¿åº¦

```Python
def longestUnivaluePath(self, root: Optional[TreeNode]) -> int:
    currMax = 0
    postorder = [(0, root, None)] # æ˜¯å¦è§è¿‡ï¼Œå½“å‰èŠ‚ç‚¹ï¼Œçˆ¶èŠ‚ç‚¹
    d = {None: 0} # ç”¨äºå­˜å‚¨èŠ‚ç‚¹å¯¹åº”çš„æœ€é•¿è·¯å¾„
    while postorder:
        seen, node, parent = postorder.pop()
        if not node: continue
        if not seen:
            postorder.append((1, node, parent))
            postorder.append((0, node.right, node.val))
            postorder.append((0, node.left, node.val))
        else:
            if node.val == parent:
                d[node] = max(d[node.left], d[node.right]) + 1
            else:
                d[node] = 0
            currMax = max(currMax, d[node.left] + d[node.right])
    return currMax
```

```Golang

```



